---
layout: post
date: 2019-07-13 05:59:28 +0000
title: 'Tree এবং Binary Tree ডাটা স্ট্রাকচার '
image: ''
tags: []

---
সাধারণ চোখে একটা গাছে কী কী দেখা যায়? গাছের মূল, গাছের বিশাল দেহখানা, গাছের ডালপালা যাকে সুন্দর করে আমরা বলি শাখা ও প্রশাখা এবং পাতা । প্রোগ্রামিং-এও এরকম গাছ আছে, যাকে ডাকা হয় Tree নামে। এই Tree একটা ডাটা স্ট্রাকচার। [গত পোষ্টে](https://nazmulhasan.me/blog/stack-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%AA-%E0%A6%B2%E0%A7%87%E0%A6%9F%E0%A7%87%E0%A6%B0-%E0%A6%AC%E0%A6%BE%E0%A6%95-%E0%A6%B8%E0%A7%87%E0%A6%B0-%E0%A6%97%E0%A6%B2-%E0%A6%AA/) বলেছিলাম ডাটা স্ট্রাকচার দুই টাইপের হয়, লিনিয়ার এবং নন লিনিয়ার। Array, Linked list এসব লিনিয়ার ডাটা স্ট্রাকচার । আর এই Tree হল নন লিনিয়ার ডাটা স্ট্রাকচার। তো দেখা যাক আমাদের এই Tree দেখতে কেমন, কিভাবে সে আমাদের সাহায্য করে।

সাধারণত একটা গাছ তার মূল থেকে শুরু হয়, এখানেও গাছের একটা মূল আছে ( থাকা উচিত, মূল ছাড়া আবার গাছ হয় নাকি? )। এই মূলকে বলা হয় Root । আমরা জানি গাছের শাখা প্রশাখা থাকে, আবার একটা শাখা প্রশাখা থেকে আরো অনেক গুলা শাখা প্রশাখা বের হয়। শাখা প্রশাখা গুলো বের হয়, বামে নইলে ডানে।  ঠিক একইরকম ভাবে আমাদের এই Tree এর ও শাখা প্রশাখা আছে যেগুলা ডানে এবং বামে বের হয়। প্রোগ্রামিং জগতে এই শাখা প্রশাখার একটা সুন্দর নাম আছে, যাকে বলা হয় Node। আমাদের এই Node ওয়ালা গাছ ( Tree ) দেখতে কেমন একটু ছবিতে দেখা যাক।

![](/uploads/tree.png)

ছবিতে যে অনেকগুলো বৃত্ত দেখা যাচ্ছে সেগুলাকে বলা হয় Node । এই Node গুলোর মধ্যে সবার উপরে যে তাকে বলা হয় Root ( গাছের মূল ), এই Root থেকেই ট্রি এর শুরু। ট্রি ডাটা স্ট্রাকচারে Root এর পরবর্তী Node গুলকে বলা হয় child ( সহজ ভাষায় গাছের ডালপালা ) আর child থাকতে পারে হয় Root এর বামে নয়তো ডানে । সেই অনুসারে child দের ডাকা হয় left child এবং right child নামে।

ছবিতে প্রতিটা child এর সামনে নাম্বার দেয়া আছে আর ব্র্যাকেটে বলা আছে তার root কে। ১ ও ২ নাম্বার node এর root আমাদের ট্রি এর মেইন root । আবার ১ নাম্বার node এর সাথে ৩ ও ৪ নাম্বার node এর কানেকশন আছে , তাহলে ৩ ও ৪ এর root হবে ১ নাম্বার node। আবার ৭ ও ৮ নাম্বার node এর সাথে, ৩ নাম্বার node এর কানেকশন আছে, তাহলে ৭ ও ৮ এর root কে? ঠিক ধরেছেন, ৩ নাম্বার node।

পাইথনে ট্রি এর কোড এর বেসিকটা লিখে দিচ্ছি

    class Node:
        def __init__(self, value):
            self.left = None 
            self.right = None 
            self.value = value 
    
    root = Node(1)
    root.left = 2
    root.right = 3 

পড়তে পড়তে একটা মজার ব্যাপার খেয়াল করেছেন? উপরের ছবিতে যদি আপনি root থেকে ১১ নাম্বার child এ আসতে চান তাহলে আপনাকে পুরো ডাটাসেট ঘুরার প্রয়োজন নেই।
root  --> ২ --> ৫ --> ১১ এই পথ ধরে  সহজেই আমরা ১১ তে পৌছে যেতে পারি।
যদি বলা হয় একটা node এর সর্বোচ্চ শুধু মাত্র ২টা child থাকতে পারবে তাহলে ব্যাপারটা কেমন হবে। চেহারাটাই বা কেমন হবে? চলুন দেখিঃ

![](/uploads/binary-tree.png)

এই টাইপের ট্রি কে বলা হয় বাইনারি ট্রি। একটা বাইনারি ট্রিতে root এর child থাকতে পারবে সর্বোচ্চ ২টা , left child এবং right child। বাইনারি ট্রি এর কোড পাইথনে দেখা যাক

    class Node:
        def __init__(self, value):
            self.left = None 
            self.right = None 
            self.value = value 
    
    root = Node(1)
    '''
           1
         /   \
      None   None
    '''
    root.left = 2
    root.right = 3 
    '''
           1
         /   \
        2     3
    '''
    
    root.left.left = Node(4)
    '''
                  1
                /   \
               2     3
              / \ 
             4  None
            / \
         None None
    '''
    
    root.left.right = Node(5)
    '''
                            1
                        /      \
                       2        3
                    /     \ 
                   4        5
                  / \      /  \
              None None  None None
    '''

ডাটা স্ট্রাকচার তো গেল, এবার এর উপকারিতা জানা যাক। ট্রি বা বাইনারি ট্রিতে ডাটা সব সময় একটা ক্রম অনুসারে সাজানো থাকে যাকে বলে hierarchical  structure। ডাটা খুঁজে বের করার জন্য আমরা অনেক টাইপের সার্চ এলগোরিদম ব্যবহার করি , কিন্তু এই বাইনারি ট্রি অনেক কম সময়ে আমাদের ডাটা খুজে এনে দিতে পারে । একটা বাস্তবিক উদাহরণ দেই । আমাদের কম্পিউটার অপারেটিং সিস্টেমের ডায়াগ্রাম নিচের ছবির মত

![](/uploads/osSystem.png)

ধরা যাক আমরা আমাদের অপারেটিং সিস্টেম এর  Home থেকে Python ফোল্ডার এর ডাটা খুঁজতে চাই । তার জন্য আমরা Home --> Documents --> Projects --> Python এই পথে এগোলে আমাদের কাজ হয়ে যাচ্ছে। আমাদের শুধু জানা প্রয়োজন কার সাথে কার সম্পর্ক। লিনিয়ার ডাটা স্ট্রাকচারে আমরা যদি একই কাজ করতে চাইতাম তাহলে আমাদের পুরো সিস্টেম ঘুরে আসা লাগতো। 

একটা মজার ব্যাপার খেয়াল করুন। একটা বাইনারি ট্রিতে যদি n সংখ্যক node থাকে তাহলে সেই বাইনারি ট্রিতে মিনিমাম log(n) সংখ্যক লেবেল আছে । বা ব্যাপারটাকে আমরা এইভাবেও বলতে পারি যে, বাইনারি ট্রিতে যদি n সংখ্যক node থাকে তাহলে সেই বাইনারি ট্রি এর height log(n) । এবার root থেকে সবচেয়ে দূরে কোন node আছে? সবার শেষেরটা বা n তম node টা । তাহলে  n তম  node এর অবস্থান হল log(n) তম লেবেলে। তাই না? তাহলে আমরা বলতে পারি সবচেয়ে বাজে অবস্থায় বা worst case এ বাইনারি ট্রি তে একটা node খুঁজতে আমাদের log(n) পরিমাণ টাইম কমপ্লেক্সিটি প্রয়োজন ।  বাইনারি ট্রি এর টাইম কমপ্লেক্সিটি কিভাবে log(n) তা নিয়ে বিস্তারিত লিখব পরের পোষ্টে।

কোড গুলার গিটহাব লিংক : [Binary Tree](https://github.com/farhapartex/data-structure)